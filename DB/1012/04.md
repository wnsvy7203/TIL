# Database

- 데이터 모델링
  - 주어진 개념으로부터 논리적인 데이터 모델을 구성하는 작업
  - 물리적인 데이터베이스 모델로 만들어 고객의 요구에 따라 특정 정보 시스템의 데이터베이스에 반영하는 작업
- 용어 정리
  - target model: 관계 필드를 가지지 않은 모델
  - source model: 관계 필드를 가진 모델
- 정리
  - M: N 관계로 맺어진 두 테이블에는 변화가 없다.
  - Django의 ManyToManyField는 중개 테이블을 자동으로 생성한다.
  - Django의 ManyToManyField는 M: N 관계를 맺는 두 모델 어디에 위치해도 상관없다.
    - 대신 필드 작성 위치에 따라 참조, 역참조 방향을 주의할 것
  - N: 1은 완전한 종속의 관계였지만 M: N은 의사에게 진찰받는 환자, 환자를 진찰하는 의사의 두 가지 형태로 모두 표현이 가능하다.

 

## Many to Many relationship

- ManyToManyField(to, **options)
  - M: N 관계 설정 시 사용하는 모델 필드
  - 하나의 필수 위치인자(M: N 관계로 설정할 모델 클래스)가 필요
  - 모델 필드의 RelatedManager를 사용하여 관련 개체를 추가, 제거 또는 만들 수 있다.
- 데이터베이스에서의 표현
  - Django는 다대다 관계를 나타내는 중개 테이블을 만든다.
  - 테이블 이름은 ManyToManyField 이름과 이를 포함하는 모델의 테이블 이름을 조합하여 생성된다.
  - 'db_table' arguments를 사용하여 중개 테이블의 이름을 변경할 수도 있다.
- Arguments
  - related_name
    - target model이 source model을 참조할 때 사용할 manager name
    - ForeignKey()의 related_name과 동일
  - through
    - 중개 모델을 직접 작성하는 경우
      - 중개 테이블을 수동으로 지정하려는 경우 through 옵션을 사용하여 사용하려는 중개 테이블을 나타내는 Django 모델을 지정할 수 있다.
    - 가장 일반적인 용도는 중개테이블에 추가 데이터를 사용해 다대다 관계와 연결하려는 경우
  - symmetrical
    - 기본 값: True
    - ManyToManyField가 동일한 모델(on self)을 가리키는 정의에서만 사용한다.
    - True일 경우
      - _set 매니저를 추가하지 않는다.
      - source 모델의 인스턴스가 target 모델의 인스턴스를 참조하면 자동으로 target 모델 인스턴스도 source 모델 인스턴스를 자동으로 참조하도록 한다(대칭).
      - 즉, 내가 당신의 친구라면 당신도 내 친구가 된다.
    - 대칭을 원하지 않는 경우 False로 설정
- Related Manager
  - N: 1 혹은 M: N 관계에서 사용 가능한 문맥(context)
  - Django는 모델 간 N: 1 혹은 M: N 관계가 설정되면 역참조시에 사용할 수 있는 manager를 생성
    - 이전에 모델 생성 시 objects라는 매니저를 통해 queryset api 를 사용했던 것처럼 related manager를 통해 queryset api를 사용할 수 있게 된다.
  - 같은 이름의 메소드여도 각 관계(N: 1, M: N)에 따라 다르게 사용 및 동작된다.
    - N: 1에서는 target 모델 객체만 사용 가능
    - M: N 관계에서는 관련된 두 객체에서 모두 사용 가능
- methods
  - add()
    - 지정된 객체를 관련 객체 집합에 추가
    - 이미 존재하는 관계에 사용하면 관계가 복제되지 않는다.
    - 모델 인스턴스, 필드 값(PK)을 인자로 허용
  - remove()
    - 관련 객체 집합에서 지정된 모델 개체를 제거
    - 내부적으로 QuerySet.delete()를 사용하여 관계가 삭제된다.
    - 모델 인스턴스, 필드 값(PK)를 인자로 허용



## M: N (Article - User)

- Article과 User의 M: N 관계 설정을 통한 좋아요 기능 구현하기

### LIKE

- 모델 관계 설정
  - like_users 필드 생성 시 자동으로 역참조에는 .article_set 매니저가 생성된다.
  - 하지만 이미 N: 1 관계에서 해당 매니저를 사용 중이므로, 구분이 불가능하다.
  - 따라서 user와 관계된 ForeignKey 혹은 ManyToManyField 중 하나에 related_name을 작성해야 하는데, 일반적으로 M: N에 바꿔주는 편이다.
- .exists()
  - QuerySet에 결과가 포함되어 있으면 True, 아니면 False 반환
  - 특히 큰 QuerySet에 있는 특정 개체의 존재와 관련된 검색에 유용하다.



## M: N (User - User)

- User 자기 자신과의 M: N 관계 설정을 통한 팔로우 기능 구현

### Profile

- 자연스러운 follow 흐름을 위한 프로필 페이지 작성

### Follow



## Fixtures

- 개요

  - Fixtures 를 사용해 모델에 초기 데이터를 제공하는 방법

  - 초기 데이터의 필요성

    - 협업하는 A, B 유저가 있다고 생각해 볼 때,

    1. A가 먼저 프로젝트를 작업 후 github에 push한다.

       - gitignore 설정으로 인해 DB는 업로드하지 않기 때문에 A가 개발하면서 사용한 데이터는 올라가지 않는다.

       1. B가 github에서 A가 push한 프로젝트를 pull(혹은 clone)한다.
          - 마찬가지로 프로젝트는 받았지만 A가 생성하고 조작한 데이터는 없는 빈 프로젝트를 받게 된다.

    - 이처럼 Django 프로젝트의 앱을 처음 설정할 때 동일하게 준비된 데이터로 데이터베이스를 미리 채우는 것이 필요한 순간이 있다.

    - Django에서는 fixtures를 사용해 앱에 초기 데이터(initial data)를 제공할 수 있다.

    - 즉, migrations와 fixtures를 사용하여 data와 구조를 공유하게 된다.

- 정의
  - Django가 데이터베이스로 가져오는 방법을 알고 있는 데이터 모음
  - DJango가 직접 만들기 때문에 데이터베이스 구조에 맞추어 작성되어 있다는 뜻

- 기본 경로

  - app_name/fixtures/
  - Django는 설치된 모든 app의 디렉토리에서 fixtures 폴더 이후의 경로로 fixtures 파일을 찾는다.

- 생성 및 로드

  - 생성: dumpdata

    - 응용 프로그램과 관련된 데이터베이스의 모든 데이터를 표준 출력으로 출력

    - 여러 모델을 하나의 json 파일로 만들 수 있다.

    - manage.py와 동일한 위치에 data가 담긴 articles.json 파일이 생성된다.

    - dumpdata의 출력 결과물은 loaddata의 입력으로 사용된다.

      `python manage.py dumpdata --indent 4 articles.article > articles.json`

  - 로드: loaddata

    - fixtures의 내용을 검색하여 데이터베이스로 로드



## Improve Query

- 개요
  - Query를 개선하는 방법
    - annotate
    - select_related
    - prefetch_related
- select_related
  - 1: 1 또는 N: 1 참조 관계에서 사용
  - SQL에서 INNER JOIN 절을 활용
    - SQL의 INNER JOIN을 사용하여 참조하는 테이블의 일부를 가져오고, SELECT FROM을 통해 관련된 필드들을 가져옴

- prefetch_related
  - M: N 또는 N:1 역참조 관계에서 사용
  - SQL이 아닌 Python을 통한 JOIN이 진행된다.
- 섣부를 최적화를 하지 말자
  - 작은 효율성에 대해서는, 97% 정도에 대해서는, 잊어버려라. 섣부른 최적화는 모든 악의 근원이다.
