# Database

## A many-to-one relationship

1. 개요
   - 관계형 데이터베이스에서의 외래 키 속성을 사용해 모델 간 N: 1 관계 설정하기

### Intro

> 관계 (Relationship)
>
> - 테이블 간의 상호작용을 기반으로 설정되는 여러 테이블 간 논리적인 연결

- 관계형 데이터베이스에서 한 테이블의 필드 중 다른 테이블의 행을 식별할 수 있는 키를 외래 키(Foreign Key, FK)라고 한다.
- RDB에서의 관계
  - 1: 1
    - 한 테이블의 레코드 하나가 다른 테이블의 레코드 하나와 관련된 경우
  - N: 1
    - 한 테이블의 0개 이상의 레코드가 다른 테이블의 레코드 한 개와 관련된 경우
    - 기준 테이블에 따라 1: N이라고도 한다.
  - M: N
    - 한 테이블의 0개 이상의 레코드가 다른 테이블의 0개 이상의 레코드와 관련된 경우
    - 양쪽 모두에서 N: 1 관계를 가진다.

### Foreign Key

1. 개념
   - 외래 키(외부 키)
   - 관계형 데이터베이스에서 한 테이블의 필드 중 다른 테이블의 행을 식별할 수 있는 키
   - 참조하는 테이블에서 1개의 키에 해당하고, 이는 참조되는 측 테이블의 기본 키(PK)를 가리킨다.
   - 참조하는 테이블의 행 1개의 값은, 참조되는 측 테이블의 행 값에 대응된다.
     - 이 때문에 참조하는 테이블의 행에는, 참조되는 테이블에 나타나지 않는 값을 포함할 수 없다.
   - 참조하는 테이블 행 여러 개가, 참조되는 테이블의 동일한 행을 참조할 수 있다.
2. 특징
   - 키를 사용하여 부모 테이블의 유일한 값을 참조(by 참조 무결성)
   - 외래 키의 값이 반드시 부모 테이블의 기본 키일 필요는 없지만 유일한 값이어야 한다.
3. 참조 무결성
   - 데이터베이스 관계 모델에서 관련된 2개의 테이블 간의 일관성을 말한다.
   - 외래 키가 선언된 테이블의 외래 키 속성(열)의 값은 그 테이블의 부모가 되는 테이블의 기본 키 값으로 존재해야 한다.



## N: 1 (Comment - Article)

1. 개요
   - Comment(N) - Article(1)
     - Comment 모델과 Article 모델 간 관계 설정
     - Ex. 0개 이상의 댓글은 1개의 게시글에 작성될 수 있다.

### 모델 관계 설정

- 게시판의 게시글과 N: 1 관계를 나타낼 수 있는 댓글 구현
  - N: 1 관계에서 댓글을 담당할 Comment 모델은 N, Article 모델은 1이 될 것

### Django Relationship fields

1. 종류
   - OneToOneField() - 1: 1 관계
   - ForeignKey() - N: 1 관계
   - ManyToManyField() - M: N 관계
2. ForeignKey(to, on_delete, **options)
   - N: 1 관계를 담당하는 Django의 모델 필드 클래스
   - Django 모델에서 관계형 데이터베이스의 외래 키 속성을 담당한다.
   - 2개의 필수 위치 인자가 필요하다.
     - 참조하는 model class
     - on_delete 옵션

### Comment Model

1. Comment 모델 정의
   - 외래 키 필드는 ForeignKey 클래스를 작성하는 위치와 관계없이 필드의 마지막에 작성된다.
   - ForeignKey() 클래스의 인스턴스 이름은 참조하는 모델 클래스 이름의 단수형(소문자)으로 작성하는 것을 권장한다(명시적인 모델 관계 파악을 위해, 참조하는 클래스 이름의 소문자로 작성하는 것).
2. ForeignKey arguments - on_delete
   - 외래 키가 참조하는 객체가 사라졌을 때, 외래 키를 가진 객체를 어떻게 처리할 지를 정의
   - 데이터 무결성을 위해서 매우 중요한 설정
   - on_delete 옵션 값
     - CASCADE: 부모 객체(참조된 객체)가 삭제됐을 때 이를 참조하는 객체도 삭제
     - PROTECT, SET_NULL, SET_DEFAULT ... 등 여러 옵션 값들이 존재한다.
3. 데이터 무결성
   - 데이터의 정확성과 일관성을 유지하고 보증하는 것
   - 데이터베이스나 RDBMS의 중요한 기능
   - 무결성 제한의 유형
     - 개체 무결성(Entity integrity)
     - 참조 무결성(Referential integrity)
     - 범위 무결성(Domain integrity)

### 관계 모델 참조

1. Relataed manager

   - Related manager는 N: 1 혹은 M: N 관계에서 사용 가능한 문맥(context)
   - Django는 모델 간 N: 1 혹은 M: N 관계가 설정되면 역참조할 때에 사용할 수 있는 manager를 생성
     - 우리가 이전에 모델 생성 시 objects라는 매니저를 통해 queryset api를 사용했던 것처럼 related manager를 통해 queryset api를 사용할 수 있게 된다.

2. 역참조

   - 나를 참조하는 테이블(나를 외래 키로 지정한)을 참조하는 것
   - 즉, 본인을 외래 키로 참조 중인 다른 테이블에 접근하는 것
   - N: 1 관계에서는 1이 N을 참조하는 상황
     - 외래 키를 가지지 않은 1이 외래 키를 가진 N을 참조

   ```python
   article.comment_set.method()
   ```

   - Article 모델이 Comment 모델을 참조(역참조)할 때 사용하는 매니저
   - article.comment 형식으로는 댓글 객체를 참조할 수 없다.
     - 실제로 Article 클래스에는 Comment와의 어떠한 관계도 작성되어 있지 않다.
   - 대신 Django가 역참조할 수 있는 comment_set manager를 자동으로 생성해 article.comment_set 형태로 댓글 객체를 참조할 수 있다.
     - N: 1 관계에서 생성되는 Related manager의 이름은 참조하는 '모델명_set' 이름의 규칙으로 만들어진다.
   - 반면 참조 상황(Comment -> Article)에서는 실제 ForeignKey 클래스로 작성한 인스턴스가 Comment 클래스의 클래스 변수이기 때문에 comment.article 형태로 작성 가능하다.

3. ForeignKey arguments - `related_name`

   - ForeignKey 클래스의 선택 옵션
   - 역참조 시 사용하는 매니저 이름(model_set manager)을 변경할 수 있다.
   - 작성 후, migration 과정이 필요하다.
   - 선택 옵션이지만 상황에 따라 반드시 작성해야 하는 경우가 생기기도 한다.
   - 작성 후 다시 원래 코드고로 복구
     - 위와 같이 변경 시, 기존 article.comment_set은 더 이상 사용할 수 없고, article.comments로 대체된다.

4. admin site 등록

   - 새로 작성한 Comment 모델을 admin site에 등록하기

### Comment 구현

1. CREATE

   - 사용자로부터 댓글 데이터를 입력받기 위한 CommentForm 작성
   - detail 페이지에서 CommentForm 출력(view 함수)
   - detail 페이지에서 CommentForm 출력(템플릿)
   - 외래 키 필드는 사용자의 입력으로 받는 것이 아니라 view 함수 내에서 받아 별도로 처리되어 저장되어야 하므로, 출력에서 제외해야 한다.
   - save 메소드의 commit 옵션을 사용해 DB에 저장되기 전 article 객체 저장

   > The `save()` method
   >
   > - save(commit=False)
   >   - Create, but don't save the new instance
   >   - 아직 데이터베이스에 저장되지 않은 인스턴스를 반환
   >   - 저장하기 전에 객체에 대한 사용자 지정 처리를 수행할 때 유용하게 사용

2. READ

   - 작성한 댓글 목록 출력
   - 특정 article에 있는 모든 댓글을 가져온 후 context에 추가
   - detail 템플릿에서 댓글 목록 출력
   - 댓글 삭제 구현

### Comment 추가 사항

1. 댓글에 관련된 아래 2가지 사항을 작성하면서 마무리
   - 댓글 개수 출력
     - DTL filter - length 사용
     - Queryset API - count() 사용
   - 댓글이 없는 경우 대체 컨텐츠 출력



## N: 1 (Article - User)

1. 개요
   - Article(N) - User(1)
   - Article 모델과 User 모델 간 관계 설정
     - 0개 이상의 게시글이 1개의 회원에 의해 작성될 수 있다.

### Referencing the User model

1. Django에서 User 모델을 참조하는 방법

   - settings.AUTH_USER_MODEL

     - 반환 값: 'accounts.User' (문자열)

     - User 모델에 대한 외래 키 또는 M: N 관계를 정의할 때 사용

     - models.py의 모델 필드에서 User 모델을 참조할 때 사용

   - get_user_model()

     - 반환 값: User Object (객체)

     - 현재 활성화(active)된 User 모델을 반환

     - 커스터마이징한 User 모델이 있을 경우는 Custom User 모델, 그렇지 않으면 User 반환

     - models.py가 아닌 다른 모든 곳에서 유저 모델을 참조할 때 사용한다.

   - 정리

     - User 모델을 참조할 때

     - models.py에서는 settings.AUTH_USER_MODEL

     - 다른 모든 곳에서는 get_user_model()

2. 모델 관계 설정

   - Article 모델에 User 모델을 참조하는 외래 키 작성
   - 기존에 존재하던 테이블에 새로운 컬럼이 추가되어야 하는 상황이기 때문에 migration 작업 필요
   - 기본적으로 모든 컬럼은 NOT NULL 제약조건이 있기 때문에 데이터가 없이는 새로 추가되는 외래 키 필드 user_id가 생성되지 않는다.
     - 따라서 기본값을 어떻게 작성할 것인지 선택해야 한다.

### CREATE

1. 개요
   - 인증된 회원의 게시글 작성 구현
   - 작성하기 전 로그인을 먼저 진행한 상태로 진행
2. ArticleForm
   - ArticleForm 출력을 확인해보면 create 템플릿에서 불필요한 필드(user)가 출력된다.
   - 이전에 CommentForm에서 외래 키 필드 article이 출력되는 상황과 동일한 상황
   - user 필드도 마찬가지로 사용자로부터 받는 것이 아니라 url의 variable routing을 통해 처리해야 한다.
3. 외래 키 데이터 누락
   - 게시글 작성 시 외래 키에 저장되어야 할 작성자 정보가 누락되면 NOT NULL constraint failed: articles_article.user_id 에러 발생
   - 게시글 작성 시 작성자 정보가 함께 저장될 수 있도록 save의 commit 옵션을 활용

### DELETE

1. 게시글 삭제 시 작성자 확인
   - 이제 게시글에는 작성자 정보가 함께 들어있기 때문에 현재 삭제를 요청하려는 사람과 게시글을 작성한 사람을 비교하여 본인의 게시글만 삭제할 수 있도록 한다.

### UPDATE

1. 게시글 수정 시 작성자 확인
   - 수정 역시 마찬가지로 수정을 요청하려는 사람과 게시글을 작성한 사람을 비교하여 본인의 게시글만 수정할 수 있도록 한다.
   - 추가로 헤당 게시글의 작성자가 아니라면, 수정/삭제 버튼을 출력하지 않도록 한다.

### READ

1. 게시글 작성자 출력
   - index 템플릿과 detail 템플릿에서 각 게시글의 작성자 출력



## N: 1 (Comment - User)

1. 개요
   - Comment(N) - User(1)
     - Comment 모델과 User 모델 간 관계 설정
     - 0개 이상의 댓글은 1개의 회원에 의해 작성될 수 있다.

### 모델 관계 설정

- Comment와 User 간 모델 관계 설정
  - Comment 모델에 User 모델을 참조하는 외래 키 작성
- Migration 진행
  - 이전에 User와 Article 모델 관계 설정 때와 마찬가지로 기존에 존재하던 테이블에 새로운 컬럼이 추가되어야 하는 상황이기 때문에 migrations 파일이 곧바로 만들어지지 않고 일련의 과정이 필요하다.
  - 기본적으로 모든 컬럼은 NOT NULL 제약조건이 있기 때문에 데이터가 없이는 새로 추가되는 외래 키 필드 user_id가 생성되지 않는다.
  - 그래서 기본값을 어떻게 작성할 것인지 선택해야 한다.
  - comment의 user_id에 어떤 데이터를 넣을 것인지 직접 입력해야 한다.

### CREATE

1. 개요
   - 인증된 회원의 댓글 작성 구현
   - 작성하기 전 로그인을 먼저 진행한 상태로 진행
2. CommentForm
   - CommentForm 출력을 확인해보면 create 템플릿에서 불필요한 필드(user)가 출력된다.
   - user 필드도 마찬가지로 사용자로부터 받는 것이 아니라 url의 variable routing을 통해 처리해야 한다.

### READ

1. 댓글 작성자 출력
   - detail 템플릿에서 각 게시글의 작성자 출력

### DELETE

- 댓글 삭제 시 작성자 확인
  - 작성자 정보가 함께 ㄷ르어있기 때문에 현재 삭제를 요청하려는 사람과 댓글을 작성한 사람을 비교하여 본인의 댓글만 삭제할 수 있도록 한다.
  - 추가로 해당 댓글의 작성자가 아니라면, 삭제 버튼을 출력하지 않도록 한다.

### 인증된 사용자에 대한 접근 제한하기

1. 개요
   - is_authenticated 와 View decorator를 활용하여 코드 정리하기
2. 인증된 사용자인 경우만 댓글 작성 및 삭제하도록 구현
3. 비인증 사용자는 CommentForm을 볼 수 없도록 구현

