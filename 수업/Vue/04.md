# Vue

## UX & UI

- 개요
  - 비슷한 것끼리 묶거나 내용을 구성해서 인지하는 것이 편하다는 것을 알고 있다. 만약 그렇지 않을 경우 불편하다는 느낌을 받거나 의사결정을 하는데 많은 시간이 걸리기도 한다.
  - 이러한 요소들은 유저와 밀접한 부분이기에 매우 중요하며 모든 서비스에서 반드시 고려되어야 한다.
- UX (User Experience)
  - 유저와 가장 가까이에 있는 분야, 데이터를 기반으로 유저를 조사하고 분석해서 개발자, 디자이너가 이해할 수 있게 소통
  - 유저가 느끼는 느낌, 태도 그리고 행동을 디자인
    - 유저 리서치, 데이터 설계 및 정제, 유저 시나리오, 프로토타입 설계 등이 필요
- UI (User Interface)
  - 유저에게 보여지는 화면을 디자인
  - UX를 고려한 디자인을 반영, 이 과정에서 기능 개선 혹은 추가가 필요한 경우 프론트엔드 개발자와 가장 많이 소통
- Interface
  - 서로 다른 두 개의 시스템, 장치 사이에서 정보나 신호를 주고받는 경우의 접점
    - 즉, 사용자가 기기를 쉽게 동작시키는데 도움을 주는 시스템
  - 우리 일상 속에 인터페이스 예시
    - CLI(command-line interface)나 GUI(Graphic User Interface)를 사용해서 컴퓨터를 조작
- 좋은 UI를 설계하기 위해서는
  - 통일된 디자인을 위한 디자인 시스템, 소통을 위한 중간 산출물, 프로토타입을 등이 필요하다.
- 디자이너와 기획자, 개발자
  - UX(직무: UX Researcher, User Researcher)
    - 구글: 사용자의 경험을 이해하기 위한 통계 모델 설계
    - MS: 리서치를 기획하고 사용자에 대한 지표 정의
    - Meta: 정성적, 정량적 방법을 사용해서 사용자 조사 실시
  - UI(직무: Product Designer, Interaction Designer)
    - 구글: 디자인 프로토타이핑 툴을 사용해서 개발 가이드르 제공
    - MS: 시각 디자인을 고려해서 체계적인 디자인 컨셉을 보여준다.
    - Meta: 제품을 이해하고 더 나은 UI Flow와 사용자 경험을 디자인

### 프로토타입

- Figma
  - 웹 기반 시스템
  - 대부분의 기능이 무료



## Vue Router

### Routing

- 개요
  - 네트워크에서 경로를 선택하는 프로세스
  - 웹 서비스에서의 라우팅
    - 유저가 방문한 URL에 대해 적절한 결과를 응답하는 것
- Routing in SSR
  - 서버가 모든 라우팅 통제
  - URL로 요청이 들어오면 응답으로 완성된 HTMl 제공
    - Django로 보낸 요청의 응답 HTML은 완성본인 상태다.
- Routing in SPA / CSR
  - 서버는 하나의 HTML만을 제공
  - 이후 모든 동작은 하나의 HTML 문서 위에서 JS 코드 활용
    - DOM을 그리는데 필요한 추가적인 데이터가 있다면 axios와 같은 AJAX 요청을 보낼 수 있는 도구를 사용하여 데이터를 가져오고 처리
  - 즉, 하나의 URL만 가질 수 있다.
- Why routing
  - 동작에 따라 URL이 반드시 바뀌어야 하는 것은 아니지만, 유저의 사용성 관점에서는 필요하다.
  - Routing이 없다면, 유저가 URL을 통한 페이지 변화를 감지할 수 없다.
  - 페이지가 무엇을 렌더링 중인지에 대한 상태를 알 수 없다.
    - 새로고침 시 처음 페이지로 돌아가거나
    - 링크 공유 시 처음 페이지만 공유할 수 있거나
  - 브라우저의 뒤로 가기 기능을 사용할 수 없다.\

### Vue Router

- 개요
  - Vue의 공식 라우터
  - SPA 상에서 라우팅을 쉽게 개발할 수 있는 기능 제공
  - 라우트(routes)에 컴포넌트를 매핑한 후, 어떤 URL에서 렌더링 할 지 알려준다.
    - 즉, SPA를 MPA처럼 URL을 이동하면서 사용 가능
    - SPA의 단점 중 하나인 "URL이 변경되지 않는다."를 해결
  - MPA(Multiple Page Application)
    - 여러 개의 페이지로 구성된 애플리케이션
    - SSR 방식으로 렌더링
- History mode
  - 브라우저의 History API를 활용한 방식
    - 새로고침 없이 URL 이동 기록을 남길 수 있다.
  - 우리에게 익숙한 URL 구조로 사용 가능
  - History mode를 사용하지 않으면 Default 값인 hash mode 로 설정된다(#을 통해 URL을 구분하는 방식).
- `router-link`
  - a 태그와 비슷한 기능 -> URL을 이동시킨다.
    - routes에 등록된 컴포넌트에 매핑된다.
    - 히스토리 모드에서 router-link는 클릭 이벤트를 차단하여 a 태그와 달리 브라우저가 페이지를 다시 로드하지 않는다.
  - 목표 경로는 'to' 속성으로 저장된다.
  - 기능에 맞게 HTML에서 a 태그로 rendering 되지만, 필요에 따라 다른 태그로 바꿀 수 있다.
- `router-view`
  - 주어진 URL에 대해 일치하는 컴포넌트를 렌더링하는 컴포넌트
  - 실제 component가 DOM에 부착되어 보이는 자리를 의미
  - router-link를 클릭하면 routes에 매핑된 컴포넌트 렌더링
  - Django에서의 block tag와 비슷하다.
    - App.vue는 base.html의 역할
    - router-view는 glock 태그로 감싼 부분
- `src/router/index.js`
  - 라우터에 관련된 정보 및 설정이 작성되는 곳
  - Django에서의 urls.py에 해당
  - routes에 URL과 컴포넌트 매핑
- `src/Views`
  - router-view에 들어갈 component 작성
  - 컴포넌트를 작성하는 곳이 두 폴더로 나뉘어진 것
  - 각 폴더 안의 .vue 파일들이 기능적으로 다른 것은 아니다.
  - views/
    - routes에 매핑되는 컴포넌트, 즉 <router-view>의 위치에 렌더링 되는 컴포넌트를 모아두는 폴더
    - 다른 컴포넌트와 구분하기 위해 View로 끝나도록 만드는 것 권장
  - components/
    - routes에 매핑된 컴포넌트의 하위 컴포넌트를 모아두는 폴더

### Vue Router 실습

- 선언적 방식 네비게이션
  - router-link의 `to`속성으로 주소 전달
    - routes에 등록된 주소와 매핑된 컴포넌트로 이동
  - Named Routes
    - 이름을 가지는 routes
      - Django에서 path 함수의 name 인자의 활용과 같은 방식
  - 동적인 값을 사용하기 때문에 v-bind를 사용해야 정상적으로 작동
- 프로그래밍 방식 네비게이션
  - Vue 인스턴스 내부에서 라우터 인스턴스에 `$router`로 접근할 수 있다.
  - 다른 URL로 이동하려면 `this.$router.push`를 사용
    - history stack에 이동할 URL을 넣는(push) 방식
    - history stack에 기록이 남기 때문에 사용자가 브라우저의 뒤로 가기 버튼을 클릭하면 이전 URL로 이동할 수 있다.
  - 결국 `<router-link :to="...">`를 클릭하는 것과 `$router.push(...)`를 호출하는 것은 같은 동작
- Dynamic Route Matching
  - 동적 인자 전달
    - URL의 특정 값을 변수처럼 사용할 수 있다.
  - Django에서의 variable routing
- lazy-loading
  - 모든 파일을 한 번에 로드하려고 하면 모든 걸 다 읽는 데 걸리는 시간이 너무 길다.
  - 미리 로드하지 않고 특정 라우트에 방문할 때 매핑된 컴포넌트의 코드를 로드하는 방식을 활용할 수 있다.
    - 모든 파일을 한 번에 로드하지 않아도 되기 때문에 최초에 로드하는 시간이 빨라진다.
    - 당장 사용하지 않을 컴포넌트는 먼저 로드하지 않는 것이 핵심이다.





## Navigation Guard

- 개요
  - Vue router를 통해 특정 URL에 접근할 때, 다른 url로 redirect를 하거나 해당 URL로의 접근을 막는 방법
- 종류
  - 전역 가드: 애플리케이션 전역에서 동작
  - 라우터 가드: 특정 URL에서만 동작
  - 컴포넌트 가드: 라우터 컴포넌트 안에 정의

### 전역 가드

- Global Before Guard
  - 다른 url 주소로 이동할 때 항상 실행
  - router/index.js에 `router.beforeEach()`를 사용하여 설정
  - 콜백 함수의 값으로 다음과 같은 3개의 인자를 받는다.
    - `to`: 이동할 URL 정보가 담긴 Route 객체
    - `from`: 현재 URL 정보가 담긴 Route 객체
    - `next`: 지정한 URL로 이동하기 위해 호출하는 함수
      - 콜백 함수 내부에서 반드시 한 번만 호출되어야 한다.
      - 기본적으로 `to`에 해당하는 URL로 이동
  - URL이 변경되어 화면이 전환되기 전 `router.beforeEach()`가 호출된다.
    - 화면이 전환되지 않고 대기 상태가 된다.
  - 변경된 URL로 라우팅하기 위해서는 `next()`를 호출해줘야 한다.
    - `next()`가 호출되기 전까지 화면이 전환되지 않는다.

### 라우터 가드

- 개요
  - 특정 route에 대해서만 가드를 설정하고 싶을 때 사용
  - `beforeEnter()`
    - route에 진입했을 때 실행된다.
    - 라우터를 등록한 위치에 추가
    - 단 매개변수, 쿼리, 해시 값이 변경될 때는 실행되지 않고 다른 경로에서 탐색할 때만 실행된다.
    - 콜백 함수는 `to, from, next`를 인자로 받는다.

### 컴포넌트 가드

- 개요
  - 특정 컴포넌트 내에서 가드를 지정하고 싶을 때 사용
  - `beforeRouteUpdate()`
    - 해당 컴포넌트를 렌더링하는 경로가 변경될 때 실행

### 404 Not Found

- 사용자가 요청한 리소스가 존재하지 않을 때 응답
- 요청한 리소스가 존재하지 않는 경우
  - 모든 경로에 대해서 404 page로 redirect 시키기
    - 기존에 명시한 경로가 아닌 모든 경로가 404 page로 redirect된다.
    - 이때, routes의 최하단부에 작성해야 한다.
- 형식은 유효하지만 특정 리소스를 찾을 수 없는 경우
  - Django에 `articles/1/`로 요청을 보냈지만, 1번 게시글이 삭제된 상태라면,
    - 404 page가 렌더링 되는 것이 아니라 기존에 명시한 `articles/:id/`에 대한 components가 렌더링된다.
    - 하지만 데이터가 존재하지 않기 때문에 정상적으로 렌더링되지 않는다.
  - 해결책
    - 데이터가 없음을 명시해서, 404 page로 이동하게 한다.



## Articles with Vue

### Detail

- 만약 서버에서 데이터를 가져왔다면
  - 데이터를 가져오는데 시간이 걸린다.
  - optional chaining(`?.`)을 통해 article 객체가 있을 때만 출력되도록 수정

