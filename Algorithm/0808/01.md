# 배열 1(Array 1)

## 알고리즘
1. 정의
    -  유한한 단계를 통해 문제를 해결하기 위한 절차나 방법. 주로 컴퓨터 용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말한다.
        - 컴퓨터 분야에서 알고리즘을 표현하는 방법은 크게 두 가지
            - 의사코드(슈도코드, Pseudocode)와 순서도
    - 간단하게 다시 말하면, 어떠한 문제를 해결하기 위한 절차
2. APS(Algorithm Problem Solving)
    - 보다 좋은 알고리즘을 이해하고 활용하는 것이다.
    - 좋은 알고리즘이란?
        - 정확성: 얼마나 정확하게 동작하는가
        - 작업량: 얼마나 적은 연산으로 원하는 결과를 얻어내는가
        - 메모리 사용량: 얼마나 적은 메모리를 사용하는가
        - 단순성: 얼마나 단순한가
        - 최적성: 더 이상 개선할 여지없이 최적화되었는가
    - 다양한 알고리즘 중에 성능을 분석할 필요성
        - 많은 문제에서 성능 분석의 기준으로 알고리즘의 작업량을 비교한다.
3. 시간복잡도(Time Complexity)
    - 실제 걸리는 시간 측정
    - 실행되는 명령문의 개수를 계산
    - 빅-오(O) 표기법
        - 시간 복잡도 함수 중 가장 큰 영향력을 주는 n에 대한 항만 표시
        - 계수(Coefficient)는 생략하여 표시
    

## 배열
1. 정의
    - 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
2. 필요성
    - 프로그램 내에서 여러 개의 변수가 필요할 때, 일일이 다른 변수명을 이용하여 자료에 접근하는 것은 매우 비효율적일 수 있다.
    - 배열을 사용하면 하나의 선언을 통해서 둘 이상의 변수를 선언할 수 있다.
    - 단순히 다수의 변수 선언을 의미하는 것이 아니라, 다수의 변수로는 하기 힘든 작업을 배열을 활용해 쉽게 할 수 있다.

### 1차원 배열
1. 선언
    - 별도의 선언 방법이 없으면 변수에 처음 값을 할당할 대 생성
    - 이름: 프로그램에서 사용할 배열의 이름
    - `Arr = list()`, `Arr = []`, `Arr = [1, 2, 3]`, `Arr = [0] * 10` (1차원 배열 선언의 예)
2. 접근
    - `Arr[0] = 10`: 배열 Arr의 0번 원소에 10을 저장하라.
3. 예제(Gravity)
    - 상자들이 쌓여 있는 방이 있다. 방이 오른쪽으로 90도 회전하여 상자들이 중력의 영향을 받아 낙하한다고 할 때, 낙차가 가장 큰 상자를 구하여 그 낙차를 리턴하는 프로그램 작성
    - 중력은 회전이 완료된 후 적용
    - 상자들은 모두 한쪽 벽면이 붙여진 상태로 쌓여 2차원의 형태를 이루며 벽에서 떨어져서 쌓인 상자는 없다.
    - 방의 가로길이는 항상 100이며, 세로 길이도 항상 100이다. 즉, 상자는 최소 0, 최대 100 높이로 쌓을 수 있다. 

## 정렬
1. 정의
    - 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순: ascending), 혹은 그 반대의 순서대로(내림차순: descending) 재배열하는 것
    - 키: 자료를 정렬하는 기준이 되는 특정 값
    - 대표적인 정렬 방식의 종류
        - 버블 정렬(Bubble Sort)
        - 카운팅 정렬(Counting Sort)
        - 선택 정렬(Selection Sort)
        - 퀵 정렬(Quick Sort)
        - 삽입 정렬(Insertion Sort)
        - 병합 정렬(Merge Sort)
### 버블 정렬(Bubble Sort)
1. 정의
    - 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
2. 정렬 과정
    - 첫 번째 원소부터 `인접한 원소끼리` 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다.
    - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.
    - 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블 정렬이라고 한다.
    - 시간 복잡도: O(n**2)
    - [55, 7, 78, 12, 42]를 버블 정렬하는 과정(오름차순, n개의 변수가 있을 때 n-1번 반복)
    ``` 첫 번째
    55 7 78 12 42
    7 55 78 12 42
    7 55 12 78 42
    7 55 12 42 78(78 정렬 완료)
    ```
    ``` 두 번째
    7 55 12 42 78
    7 12 55 42 78
    7 12 42 55 78
    ```
    ```python
    def BubbleSort(a, N): # 정렬할 List, N의 원소 개수
        for i in range(N-1, 0, -1): # 범위의 끝 위치
            for j in range(0, i):
                if a[j] > a[j+1]:
                    a[j], a[j+1] = a[j+1], a[j]
    ```


### 카운팅 정렬(Counting Sort)
1. 정의
    - 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
2. 제한 사항
    - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능: 각 항목의 발생 횟수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문이다.
    - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다.
    - 시간 복잡도: O(n + k) -> n은 리스트 길이, k는 정수의 최댓값
3. 정렬 과정
    - [0, 4, 1, 3, 1, 2, 4, 1]을 카운팅 정렬하는 과정
    - 1단계
        - Data에서 각 항목들의 발생 횟수를 세고, 정수 항목들로 직접 인덱스되는 카운트 배열 counts에 저장한다.
    - 2단계
        -  정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts의 원소를 조정한다.
    ```
    data
    0 4 1 3 1 2 4 1

    counts
    [0] [1] [2] [3] [4]
     1   3   1   1   2
     1   4   5   6   8

    temp: data 맨 마지막 인덱스부터 차례차례
    0 1 1 1 2 3 4 4
    ```
    ```python
    def Counting_Sort(A, B, k):
        # A [] -- 입력 배열 (1 to k)
        # B [] -- 정렬된 배열
        # C [] -- 카운트 배열

        C = [0] * (k+1)

        for i in range(0, len(A)):
            C[A[i]] += 1
        
        for i in range(1, len(C)):
            C[i] += C[i-1]

        for i in range(len(B)-1, -1, -1):
            C[A[i]] -= 1
            B[C[A[i]]] = A[i]
    ```
4. 정렬 알고리즘 비교
    - 버블 정렬: `O(n**2) ~ O(n**2)` 비교와 교환 -> 코딩이 가장 손쉽다
    - 카운팅 정렬: `O(n+k) ~ O(n+k)` 비교환 방식 -> n이 비교적 작을 때만 가능하다.
    - 선택 정렬: `O(n**2) ~ O(n**2)` 비교와 교환 -> 교환의 횟수가 버블, 삽입정렬보다 적다.
    - 퀵 정렬: `O(n log n) ~ O(n**2)` 분할 정복 -> 최악의 경우 O(n**2)이지만, 평균적으로는 가장 빠르다.
    - 삽입 정렬: `O(n**2) ~ O(n**2)` 비교와 교환 -> n의 개수가 작을 때 효과적이다.
    - 병합 정렬: `O(n log n) ~ O(n log n)` 분할 정복 -> 연결리스트의 경우 가장 효율적인 방식


## 완전검색
- 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
- Brute-force 혹은 generate-and-test 기법이라고도 불린다.
- 모든 경우의 수를 테스트한 후, 최종 해법을 도출한다.
- 일반적으로 경우의 수가 상대적으로 작을 때 유용하다.
- 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 적다.
- 주어진 문제를 풀 때, 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직하다.

1. Baby-gin 접근
    - 고려할 수 있는 모든 경우의 수 생성
        - 6개의 숫자로 만들 수 있는 모든 숫자 나열(중복 포함)
        - 순열을 생성하여, 앞의 3자리와 뒤의 3자리를 잘라, run과 triplet 여부를 테스트하고 최종적으로 baby-gin인지 판단
    - 완전검색 아닌 방법?
        - 6개의 숫자가 6자리의 정수 값으로 입력되므로, counts 배열의 각 원소를 체크하여 run triplet 및 baby-gin 여부 판단
2. 순열(Permutation)
    - 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
    - {1, 2, 3}을 포함하는 모든 순열을 생성하는 함수
        - 동일한 숫자가 포함되지 않았을 때, 각 자리 수 별로 loop을 이용해 아래와 같이 구현할 수 있다.
        ```python
        for i1 in range(1, 4):
            for i2 in range(1, 4):
                if i2 != i1:
                    for i3 in range(1, 4):
                        if i3 != i1 and i3!= i2:
                            print(i1, i2, i3)
        ```

## 탐욕 알고리즘(Greedy Algorithm)
1. 정의
    - 최적해를 구하는 근시안적 방법
    - 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.
    - 각 선택 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없다.
    - 일반적으로, 머릿속에 떠오르는 생각을 바로 구현하면 Greedy 접근이 된다.
2. 동작 과정
    - 해 선택: 현재 상태에서 부분 문제의 최적해를 구한 뒤, 이를 부분해 집합(Solution Set)에 추가한다.
    - 실행 가능성 검사: 새로운 부분해 집합이 실행 가능한지를 확인한다. 곧, 문제의 제약 조건을 위반하지 않는지를 검사한다.
    - 해 검사: 새로운 부분해 집합이 문제의 해가 되는지를 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 해 선택부터 다시 시작한다.